*type=  draft

page=   thesis
url=    draft-transformation_and_analysis_of_functional_programs-4_jun_2008.pdf
title=  Transformation and Analysis of Functional Programs
date=   04 June 2008
note=   Initial submission of PhD thesis
text=
        This thesis describes techniques for transforming and analysing functional programs. We operate on a core language, to which Haskell programs can be reduced. We present a range of techniques, all of which have been implemented and evaluated.

        We make programs shorter by defining a library which abstracts over common data traversal patterns, removing boilerplate code. This library only supports traversals having value-specific behaviour for one type, allowing a simpler programming model. Our library allows concise expression of traversals with competitive performance.

        We make programs faster by applying a variant of supercompilation. As a result of practical experiments, we have identified modifications to the standard supercompilation techniques -- particularly with respect to let bindings and the generalisation technique.
        
        We make programs safer by automatically checking for potential pattern-match errors. We define a transformation that takes a higher-order program and produces an equivalent program with fewer functional values, typically a first-order program. We then define an analysis on a first-order language which checks statically that, despite the possible use of partial (or non-exhaustive) pattern matching, no pattern-match failure can occur.


page=   parsing
url=    draft-parser_design-17_nov_2004.pdf
title=  Parser Design
date=   17 Nov 2004
note=   very early notes on my ideas regarding parsing.


page=   catch
url=    draft-catch-02_apr_2008.pdf
title=  Not All Patterns, But Enough - an automatic verifier for partial but sufficient pattern matching
author= Neil Mitchell and Colin Runciman
date=   02 Apr 2008
note=   submitted to <a href="http://www.icfpconference.org/icfp2008/">ICFP 2008</a>
text=
    We describe an automated analysis of Haskell 98 programs to
    check statically that, despite the possible use of partial (or nonexhaustive)
    pattern matching, no pattern-match failure can occur.
    Our method is an iterative backward analysis using a novel form
    of pattern-constraint to represent sets of data values. The analysis
    is defined for a core first-order language to which Haskell 98
    programs are reduced. Our analysis tool has been successfully
    applied to a range of programs, and our techniques seem to scale
    well. Throughout the paper, methods are represented much as we
    have implemented them in practice, again in Haskell.
